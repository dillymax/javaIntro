		java 
			
hdd->ram->micro processor(cpu)

hdd -> storage type -> files    (magnetic technology used ,its nature is slow)
ram -> storage type ->bytes    (semi-conductor technology used so its naturally fast)
mp  -> storage type ->register (semi-conductor technology used )


hdd->RAM->MP
*ram is faster than hdd (when sending information to processor)
*register is faster than byte(ram)

source code(index.java) ->comipler ->bytecode ->jvm ->MLL -> processor

compiler ->convert source code into bytecode(intermidiate code it is portable)
jdk ->java development kit (using this you can write and run the java code)
jre ->java run time environment (OS will set up the environment for jre in RAM )
jvm -> java virtual machine (inside jre we have jvm + library tools)


github most commonly used comments
git init
git status
git add index.txt
git add -a
git add .
git log
git commit -m "first version"
git add remote origin url
git push -u master
git congif
git config -list
etc need to write more comments

eg:
class FirstProgram
{
public static void main(String args[])
{
System.out.println("hello world");
}
}

main method -> is starting point java program because whenever you run code then  jvm will first 
search the main method to start execute

static ->if you using static keyword(reserve word) in method , 
then jvm will not create object to access that method ,jvm direcly accessthat method

void ->its does'nt return anything instead void you can other return type alsoe eg : int , String , boolean etc

public ->when you make your method as public then that method can visible to everywhere or accessible to accross(entire) the project.

*In one java file you can write n number of classes but you must specify main method in one class for starting point of code
*when you make your class as public then that class name should be as file name otherwise it will error

indentifier
*its means names in java
*eg : class name , method name , varibles name and lable name .

reserve words or keywords
*already jvm have specail meaning for these keywords
*eg : if , else etc

datatypes
byte
short
int
long
double
flote
boolean

*during runtme jvm will allocate memorys in RAM
*so be carefull to create datatypes because whenever you creating more varibles then that time if your Ram size  is small  during
runtime it will throw error


COMPOSER
*when perform with whole with using any of operator then the resultant will be int only irrespective of where its store
*when you perform with wholeNumber as a direct literal then composer treat that whole number as int only 
either we can store byte or short
eg:
int a =10; (valid)
*when you perform with realNumber as a direct literal then composer treat that real number as double only 
float a = 10.5;  (invalid) 
float b = 10.5f; (valid)  here realNumber as a direct literal then composer treat that real number as double only 
                          so we put suffix 'f' at the end and to telling composer don't treat as double , treat as float 

*whenever you perform integer by integer it will lead truncation to Zero irrespective of where you store 
int a=25;
int b=2;       real value is 12.5
int c =a/b;   //12    truncation to Zero
float d =a/b; //12.0  truncation to Zero
*whenever you perform with varibles then composer came into the picture for type check because java is strictly type cheacked language
eg :
int a =10; (valid)
byte b=a; (invalid)Compile time error (here complier will check int can store in byte , answer is no )
*jvm only allocate memorys varible and assign values to the varibles during , 
compiler can,t assign values varibles it will only type check
eg:
int a=10;
int b=a+1;

type casting
*implicit type casting
*explicit type casting

1,char->byte->short->int->long->float->long
left to right(implicit type casting)
2, byte<-short<-int<-long<-float<-long
right to left (explicit type casting)


class Student{
    //by default jvm will fill the varibles with default values in heap area when you create obj for Student
    //instance varible
    int id;
    int age;
    String name;
}
class Student{
     //instance varible
    int a; 
    public static void main(){
        //creating obj using new keyword and storing into the Student type varible
        //std ->refference varible because we here storing Student type object
int local ;
System.out.println(local) //0
System.out.println(local); //CE : because jvm only initialize default values to 
                                  instance varible only not an local varible so we should initial local varible
    Student std = new Student();
    std.name = "dilly";
    std.age =22;
    }
}

//default value for datatypes
int ->0
boolean ->false
float ->0.0
string ->null

//DURING EXCUTION(RUN TIME) TIME JVM WILL ALLOCATE MEMORIES AND EXCUTE 
//HEAP AND STACK AND METHOD AREA
RAM->JRE->JVM+library files.

*JVM search main method in method area and invoking that method and put it into the stack area because 
main thread start excute whichever present in stack area only otherwise program didn'nt execute

METHOD AREA
We have .class files HERE DURING runtime
HEAP AREA
*whenever you create obj in program  , jvm will allocate memorys for 
obj in  heap area at the same time jvm will  allocate memorys for instance varible and fill with default vaules in part of obj
